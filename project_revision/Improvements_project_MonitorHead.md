# Доработки проекта MonitorHead

# Содержание

1. [Беспроводное соединение](#беспроводное-соединение-wireless-connection)
2. [Конкретные доработки для беспроводной версии](#конкретные-доработки-для-беспроводной-версии-версии-2)




# Беспроводное соединение (wireless connection)

## История обсуждения проекта беспроводной системы с ESP32

### Вопрос 1: Исходная архитектура системы
**Пользователь:** Разрабатываю устройство на базе ESP32, которое собирает данные с датчика MPU6050 и двух джойстиков (тактовая кнопка) - моменты нажатия кнопок. Данные собираются в пакет и отправляются на компьютер по WiFi. Хочу сделать джойстики беспроводными, чтобы они передавали момент нажатия на основной модуль ESP32. Получается 3 модуля: 

1) ESP32 с датчиком, 
2) кнопка первого джойстика, 
3) кнопка второго джойстика. 

Как организовать соединение, если WiFi первого модуля уже используется для связи с компьютером?

### Ответ 1: Варианты беспроводной связи
**Ассистент:** Предлагаю несколько вариантов для реализации беспроводных джойстиков:

1. **BLE (Bluetooth Low Energy)** - оптимальный вариант
   - ESP32 поддерживает одновременную работу WiFi и BLE
   - Основной модуль работает как BLE Central для приема данных с джойстиков
   - Джойстики работают как BLE Peripheral, отправляя данные при нажатии кнопки

2. **ESP-NOW** - альтернативный вариант
   - Протокол от Espressif для прямого обмена между ESP32
   - Низкая задержка (1-2 мс), простая настройка
   - Не требует подключения к точке доступа

3. **WiFi Mesh Network**
   - Более сложная настройка
   - Все устройства образуют единую сеть

**Рекомендация:** Использовать BLE, так как он позволяет одновременно работать WiFi (для связи с компьютером) и Bluetooth (для связи с джойстиками).

### Вопрос 2: Выбор модулей для джойстиков
**Пользователь:** Какие модули BLE больше подойдут для подобного проекта? Какие нужно поставить в джойстиках?

### Ответ 2: Рекомендации по выбору модулей
**Ассистент:** Лучшие варианты для джойстиков:

1. **ESP32-C3-MINI-1** - компактный, энергоэффективный, программируемый
2. **ESP32-PICO-MINI** - очень маленький, все на одном чипе
3. **nRF52840 модули** - максимальная энергоэффективность, но дороже

**Сравнение:**
- ESP32-C3-MINI: ~5 мкА в глубоком сне, ~$3 за штуку
- nRF52840: ~0.4 мкА в глубоком сне, дороже, сложнее программировать

**Рекомендация:** Для баланса цены, простоты разработки и автономности использовать ESP32-C3-MINI.

### Вопрос 3: Логика работы модулей джойстиков
**Пользователь:** Хочу использовать модуль ESP32S wroom-32. Можем сделать логику работы модуля так, чтобы он был после загрузки в режиме ожидания нажатия кнопки (активном режиме) 10 минут. Таймер 10 минут должен настраиваться (вынести переменную в начало кода). Таймер должен сбрасываться каждый раз от последнего нажатия кнопки.

### Ответ 3: Код для ESP32 джойстика с таймером
**Ассистент:** Предлагаю следующий код для джойстика на ESP32:

```cpp
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include <esp_sleep.h>

// Настройки
#define BUTTON_PIN 0
#define INACTIVITY_TIMEOUT 10  // Таймер бездействия в МИНУТАХ

// BLE настройки
#define SERVICE_UUID "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define CHARACTERISTIC_UUID "beb5483e-36e1-4688-b7f5-ea07361b26a8"
#define DEVICE_NAME "Wireless_Joystick_1"

// Глобальные переменные
BLEServer *pServer = NULL;
BLECharacteristic *pCharacteristic = NULL;
bool deviceConnected = false;
bool oldDeviceConnected = false;
unsigned long lastActivityTime = 0;
const unsigned long inactivityTimeout = INACTIVITY_TIMEOUT * 60 * 1000;

// Функции
void updateActivityTime() {
  lastActivityTime = millis();
}

void goToDeepSleep() {
  Serial.println("Переход в глубокий сон...");
  if (pServer) {
    pServer->stopAdvertising();
  }
  BLEDevice::deinit();
  esp_sleep_enable_ext0_wakeup((gpio_num_t)BUTTON_PIN, 0);
  Serial.flush();
  delay(100);
  esp_deep_sleep_start();
}

void checkInactivity() {
  if (deviceConnected) {
    if (millis() - lastActivityTime > inactivityTimeout) {
      Serial.println("Таймер истек. Отключаемся...");
      pServer->disconnectClient();
      delay(100);
      goToDeepSleep();
    }
  }
}

void sendButtonState() {
  if (deviceConnected) {
    uint8_t value = 1;  // Значение при нажатии
    pCharacteristic->setValue(&value, 1);
    pCharacteristic->notify();
    updateActivityTime(); // Сброс таймера при активности
  }
}

void setup() {
  Serial.begin(115200);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  
  // Инициализация BLE
  BLEDevice::init(DEVICE_NAME);
  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());
  
  BLEService *pService = pServer->createService(SERVICE_UUID);
  pCharacteristic = pService->createCharacteristic(
    CHARACTERISTIC_UUID,
    BLECharacteristic::PROPERTY_READ |
    BLECharacteristic::PROPERTY_NOTIFY
  );
  
  pService->start();
  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(SERVICE_UUID);
  pAdvertising->setScanResponse(true);
  pAdvertising->setMinPreferred(0x06);
  pAdvertising->setMinPreferred(0x12);
  BLEDevice::startAdvertising();
  
  Serial.println("Ожидание подключения...");
  updateActivityTime();
}

void loop() {
  // Обработка подключения/отключения BLE
  if (!deviceConnected && oldDeviceConnected) {
    delay(500);
    pServer->startAdvertising();
    oldDeviceConnected = deviceConnected;
  }
  
  if (deviceConnected && !oldDeviceConnected) {
    oldDeviceConnected = deviceConnected;
  }
  
  // Чтение состояния кнопки
  if (digitalRead(BUTTON_PIN) == LOW) {
    delay(20); // Антидребезг
    if (digitalRead(BUTTON_PIN) == LOW) {
      sendButtonState();
      Serial.println("Кнопка нажата!");
    }
  }
  
  checkInactivity(); // Проверка таймера бездействия
  delay(10);
}
```

### Вопрос 4: Оценка выбранных компонентов
**Пользователь:** Определился с модулями:
- Для джойстиков: ESP32-C3-MINI, аккумулятор 18350 li-ion 1100 mAh, зарядный модуль TP4056, выключатель, тактовая кнопка 10*10
- Для основного блока: ESP32 Dev Module, аккумулятор 18650 li-ion 3400 mAh, TP4056, выключатель, 2 тактовые кнопки, OLED дисплей 128*64 i2c 0.96", IMU BNO080

Как считаешь, хороший набор или что-то нужно поменять?

### Ответ 4: Оценка и рекомендации по компонентам
**Ассистент:** Отличный выбор! Вот анализ и рекомендации:

**Сильные стороны:**
1. Джойстики: ESP32-C3-MINI идеально подходит - компактный, энергоэффективный
2. Основной блок: BNO080 вместо MPU6050 - существенное улучшение (нет дрифта, встроенная калибровка)
3. Адекватные емкости аккумуляторов

**Критические доработки:**

1. **Преобразователи напряжения:**
   - Li-ion: 3.0-4.2В, а ESP32 требуется стабильные 3.3В
   - Для джойстиков: HT7333 LDO стабилизатор (300mA)
   - Для основного блока: MP1584EN DC-DC понижающий преобразователь

2. **Защита аккумуляторов:**
   - Используйте TP4056 модули С ЗАЩИТОЙ (синяя плата с DW01 чипом)
   - Или отдельно добавьте DW01A + 8205A плату защиты

3. **Схема подключения:**

**Для джойстиков:**
```
[18350] → [TP4056 с защитой] → [Выключатель] → [HT7333 3.3V] → ESP32-C3-MINI
```

**Для основного блока:**
```
[18650] → [TP4056 с защитой] → [Выключатель] → [MP1584EN 3.3V] → Распределение:
                                     ├── ESP32 Dev (3.3V)
                                     ├── OLED (3.3V) 
                                     └── BNO080 (3.3V)
```

4. **Потребление:**
   - Основной блок: ~100-200mA (ESP32 + OLED + BNO080)
   - При 3400mAh: 17-34 часов непрерывной работы
   - Рекомендую добавить режим глубокого сна

5. **Программные рекомендации для BNO080:**
```cpp
#include "Adafruit_BNO08x.h"
// BNO080 дает готовые кватернионы без дрифта
```

**Итог:** Набор очень хорош. Обязательно добавьте стабилизаторы напряжения и защитные платы для аккумуляторов. Бюджет примерно $55-75 за весь комплект.





# Конкретные доработки для беспроводной версии (версии 2)

1. Общие:
- сделать основной модуль и рукоятки беспроводные.

2. Основной модуль:
- проверить возможность замены на ESP32-C3-MINI;
- добавить компактности устройству;
- применить только один аккумулятор 18650 на 3400 мАч;
- заменить модуль заряда с защитой на базе чипа IP2326, 2S аккумуляторной батареи (соединенных последовательно, с балансировкой и защитой с поддержкой быстрой зарядки QC) на модуль заряда с защитой для 1S TP4056;
- установить модуль индикации уровня напряжения, чтобы понимать оставшийся уровень заряда;
- добавить OLED-дисплей для отображения сервисной информации;
- добавить тактовые кнопки для управления основным модулем;
- заменить IMU на более современный BNO080.

Примерный расчет потребления основоного блока:

- ESP32 Dev (активно) ≈ 80-150mA;
- OLED 0.96" ≈ 20-40mA;
- Светодиодный индикатор зарада ≈ 10-20mA;
- BNO080 ≈ 3-10mA.

Итого: ~110-220mA.

3. Джойстики или рукоятки (переработка на беспроводные):
- убрать провода;
- в качестве контроллера использовать ESP32-C3-MINI;
- применить аккумулятор 18350 на 1100 мАч из-за ограничений в габаритах, баланс между ёмкостью и габаритами джойстика;
- добавить модуль индикации уровня напряжения; 
- добавлем модуль заряда аккумулятора 1S с защитой (например TP4056);
- добавляем 2-х позиционный выключатель для полного отключения потребителей от батареи.

4. Улучшения:
- вибромотор в джойстиках для тактильной отдачи;
- водостойкость - покрыть платы конформным лаком.

### Конкретные компоненты для заказа (Алиэкспресс)

Для джойстиков (на каждый):
1. ESP32-C3-MINI - 1 модуль
2. Аккумулятор 18350 1100mAh (ищите с защитной платой)
3. TP4056 модуль с защитой (синяя плата)
4. HT7333 LDO стабилизатор
5. Кнопка тактовая 10x10 (6x6 тоже подойдет)
6. Выключатель 2-х позиционный миниатюрный
7. Светодиодный индикатор напряжения.

Для основного блока:
1. ESP32 Dev Kit Module (38 pin)
2. Аккумулятор 18650 3400mAh (Samsung/Panasonic) с контактами для припайки проводов
3. Светодиодный индикатор напряжения.
4. TP4056 модуль с защитой
5. MP1584EN понижающий преобразователь
6. OLED 0.96" I2C (адрес 0x3C или 0x3D)
7. BNO080 модуль (готовый, с кварцем)
8. Выключатель 2-х позиционный миниатюрный
9. Кнопки тактовые (2 шт)